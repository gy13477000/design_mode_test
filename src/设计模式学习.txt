单例模式：jvm中只产生一个实例
工厂模式
工厂方法模式
抽象工厂模式
建造者模式：封装一个产品的构造过程，并允许按照步骤构建。
原型模式
适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。
外观模式：提供一个统一的接口，来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
桥接模式：使实现和抽象放在两个不同的类层次中而使他们可以独立改变
过滤器模式
迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
组合模式：允许你想对象组合成树形结构来表现“整体和部分”的层次结构，组合能让客户以一致的方式来处理个别对象已经对象组合
装饰器模式：动态地将责任附加到对象上，若要扩展功能，装饰着提供了比继承更有弹性的替代方案。(装饰器和被装饰者着都需要实现同一个接口)
享元模式
代理模式 ：为另一个对象提供一个替身，控制对其的访问(代理和代理着都需要实现同一个接口)
责任链模式：一个对象可以被N个对象处理，类似生产线。
命令模式
解释器模式
中介者模式：来集中相关对象之间复杂的沟通和控制方式
备忘录模式
观察者模式：出版者+订阅者=观察着模式
状态模式：允许对象内部状态改变时改变他的行为，对象看起来好像修改了它的类
空对象模式
策略模式：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
模板模式：在一个父类方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。
访问者模式
MVC 模式
业务代表模式
组合实体模式
数据访问对象模式
前端控制器模式
拦截过滤器模式
服务定位器模式
传输对象模式